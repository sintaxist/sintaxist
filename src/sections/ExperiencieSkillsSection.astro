---
import SectionLayout from "@/layouts/SectionLayout.astro";
import SkillCategory from "@/components/SkillCategory.astro";
import ExperienceItem from "@/components/ExperienceItem.astro";
import Button from "@/components/ui/Button.astro";
import SectionTitle from "@/components/ui/SectionTitle.astro";


interface Experience {
  title: string;
  jobs: any[];
  cta_download_cv: string;
}
interface Props {
  experience: Experience,
  skills?: any
}

const { experience, skills } = Astro.props;

const lang = Astro.url.pathname.split("/")[1] || "es";
const cvPath = `/cv/Alejandro-Canek-CV-${lang}.pdf`;
---

<SectionLayout
  id="experience"
  color="primary"
  className="flex flex-col gap-8 sm:gap-12"
  secondChild={true}
  secondId="skills"
>
  <!-- Experience -->

  <SectionTitle color="secondary" text={experience.title} tag="h2" />

  <div class="flex flex-col gap-12 md:gap-16">
    {
      experience.jobs.map((job, index) => (
        <ExperienceItem
          job={job}
          isLast={index === experience.jobs.length - 1}
        />
      ))
    }
  </div>

  <div class="md:mx-auto">
    <Button
      as="a"
      href={cvPath}
      text={experience.cta_download_cv}
      fill={true}
      color="secondary"
      arrow={true}
      download
    />
  </div>

  <!-- Skills -->

  <div slot="secondary" class="flex flex-col gap-8 sm:gap-12">
    <SectionTitle color="secondary" text={skills.title} tag="h2" />

    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-12 gap-y-10">
      {
        skills.categories.map((category, index) => (
          <article
            class="anim-item flex flex-col gap-4"
            data-delay={index * 200}
            data-animate="text"
          >
            <SkillCategory {category} />
          </article>
        ))
      }
    </div>
  </div>
</SectionLayout>
<script>

  document.addEventListener("astro:page-load", () => {

  const experienceItems = document.querySelectorAll(".experience-item");

  if (experienceItems.length > 0) {
    const firstItemObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const firstIcon = entry.target.querySelector(".timeline-icon");
          if (firstIcon) {
            firstIcon.classList.toggle("is-pulsing", entry.isIntersecting);
          }
        });
      },
      { threshold: 0.9 }
    );

    firstItemObserver.observe(experienceItems[0]);

    const handleTimelineScroll = () => {
      const triggerPoint = window.innerHeight * 0.8;

      experienceItems.forEach((item, index) => {
        const line = item.querySelector(".timeline-line");
        if (!line) return;

        if (line instanceof HTMLElement) {
          const rect = item.getBoundingClientRect();
          const elementTop = rect.top;

          let progress = (triggerPoint - elementTop) / rect.height;
          let clampedProgress = Math.max(0, Math.min(progress, 1));

          line.style.transform = `scaleY(${clampedProgress})`;

          const nextItem = experienceItems[index + 1];
          if (nextItem) {
            const nextIcon = nextItem.querySelector(".timeline-icon");
            if (nextIcon) {
              nextIcon.classList.toggle("is-pulsing", clampedProgress === 1);
            }
          }
        }
      });
    };

    let isTicking = false;
    window.addEventListener("scroll", () => {
      if (!isTicking) {
        window.requestAnimationFrame(() => {
          handleTimelineScroll();
          isTicking = false;
        });
        isTicking = true;
      }
    });

    handleTimelineScroll();
  }
})
</script>
