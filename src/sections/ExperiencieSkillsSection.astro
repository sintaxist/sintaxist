---
import SectionLayout from "@/layouts/SectionLayout.astro";
import SkillCategory from "@/components/SkillCategory.astro";
import ExperienceItem from "@/components/ExperienceItem.astro";
import Button from "@/components/ui/Button.astro";
import SectionTitle from "@/components/ui/SectionTitle.astro";

const { experience, skills } = Astro.props;

const lang = Astro.url.pathname.split("/")[1] || "es";
const cvPath = `/cv/Alejandro-Canek-CV-${lang}.pdf`;
---

<SectionLayout
  id="experience"
  color="primary"
  className="flex flex-col gap-8 sm:gap-12"
  secondChild={true}
  secondId="skills"
>
  <!-- Experience -->

  <SectionTitle color="secondary" text={experience.title} tag="h2" />

  <div class="flex flex-col gap-12 md:gap-16">
    {
      experience.jobs.map((job, index) => (
        <ExperienceItem
          job={job}
          isLast={index === experience.jobs.length - 1}
        />
      ))
    }
  </div>

  <div class="md:mx-auto">
    <Button
      as="a"
      href={cvPath}
      text={experience.cta_download_cv}
      fill={true}
      color="secondary"
      arrow={true}
      download
    />
  </div>

  <!-- Skills -->

  <div slot="secondary" class="flex flex-col gap-8 sm:gap-12">
    <SectionTitle color="secondary" text={skills.title} tag="h2" />

    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-12 gap-y-10">
      {
        skills.categories.map((category, index) => (
          <article
            class="anim-item flex flex-col gap-4"
            data-delay={index * 200}
            data-animate="text"
          >
            <SkillCategory {category} />
          </article>
        ))
      }
    </div>
  </div>
</SectionLayout>
<script>
  // --- LÓGICA SECUENCIAL Y BIDIRECCIONAL PARA LA LÍNEA DE TIEMPO ---
const experienceItems = document.querySelectorAll('.experience-item');

if (experienceItems.length > 0) {
  // Parte 1: Observador para el primer ícono (ahora reversible)
  const firstItemObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      const firstIcon = entry.target.querySelector('.timeline-icon');
      if (firstIcon) {
        // Añade o quita la clase dependiendo de si el elemento está visible o no
        firstIcon.classList.toggle('is-pulsing', entry.isIntersecting);
      }
    });
  }, { threshold: 0.5 });

  firstItemObserver.observe(experienceItems[0]);


  // Parte 2: Listener de scroll para las líneas y los siguientes íconos
  const handleTimelineScroll = () => {
  const triggerPoint = window.innerHeight * 0.8;

  experienceItems.forEach((item, index) => {
    const line = item.querySelector('.timeline-line');
    // Si es el último item, no tiene línea, así que salimos.
    if (!line) return; 

    // --- 👇 LA CORRECCIÓN ESTÁ AQUÍ 👇 ---
    // Verificamos que 'line' es un HTMLElement antes de usar .style
    if (line instanceof HTMLElement) {
      const rect = item.getBoundingClientRect();
      const elementTop = rect.top;
      
      let progress = (triggerPoint - elementTop) / rect.height;
      let clampedProgress = Math.max(0, Math.min(progress, 1));

      // Ahora TypeScript sabe que 'line.style' es válido
      line.style.transform = `scaleY(${clampedProgress})`;

      const nextItem = experienceItems[index + 1];
      if (nextItem) {
        const nextIcon = nextItem.querySelector('.timeline-icon');
        if (nextIcon) {
          nextIcon.classList.toggle('is-pulsing', clampedProgress === 1);
        }
      }
    }
  });
};

  let isTicking = false;
  window.addEventListener('scroll', () => {
    if (!isTicking) {
      window.requestAnimationFrame(() => {
        handleTimelineScroll();
        isTicking = false;
      });
      isTicking = true;
    }
  });

  handleTimelineScroll();
}
</script>
